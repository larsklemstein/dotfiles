# ============================================================================
# generic stuff
# ============================================================================

alias vi=nvi

# tmpdir
export TMPDIR="$HOME/tmp"
[ -d "$TMPDIR" ] || mkdir -p -- "$TMPDIR"

# sane defaults
ulimit -c 0 -n 4096
umask 002

# detect OS
case "$(uname -s)" in
    Darwin) THIS_OS=mac ;;
    Linux)  THIS_OS=linux ;;
    *)      THIS_OS=unknown ;;
esac
export THIS_OS

[ "$THIS_OS" = linux ] && alias open=exo-open

# paths

export EZA_CONFIG_DIR="$HOME/.config/eza"

export XDG_CONFIG_HOME="$HOME/.config"
export XDG_CACHE_HOME="$HOME/.cache"
export XDG_DATA_HOME="$HOME/.local/share"

export WORK="$HOME/work"
export EDU="$HOME/edu"
export DF="$HOME/.dotfiles"
export NCONF="$DF/config/nvim"
export NCONF_LUA="$NCONF/lua/config"

alias s='source'

alias eci='nvim $DF/dot.common_interactive_sh'

# short cuts for dirs and files
cdd() {
  local sc_rc=$HOME/.places

  if [ ! -f "$sc_rc" ]
  then
    echo "No $sc_rc found!" >&2
    return 1
  fi

  local choosen
  choosen=$(fzf < $sc_rc)

  [ -z "$choosen" ] && return

  choosen="$(eval echo $choosen)"

  if [ -f "$choosen" ]
  then
    nvim "$choosen"
  elif [ -d "$choosen" ]
  then
    cd "$choosen"
  else
    echo "Do not know what to to with \"$choosen\" (exists neither as file nor dir)" >&2
  fi
}

# --- jump aliases
alias cdw='cd "$WORK" && lltr'
alias cde='cd "$EDU" && lltr'
alias cdnc='cd "$NCONF" && lltr'
alias cdncl='cd "$NCONF_LUA" && lltr'
alias cddf='cd "$DF" && lltr'

export ca=' --color=always '

# --- ls aliases (eza)
export EZA_TREE_LEVEL=5
alias l="eza --git --icons=auto --group-directories-first -X --level=${EZA_TREE_LEVEL:-8} --color=always"
alias ll='l -l'
alias la='l -a'
alias lla='l -la'
alias llt='ll --sort age'
alias lltr='llt --reverse'

# --- grep aliases
alias grep='grep --color=auto'
alias egrep='grep -E'
alias fgrep='grep -F'

# misc tools
alias dua="$BREW_BIN/dua -t4 interactive"
alias nrg='rg --color=never'
alias webp2jpg='for w in *.webp; do convert "$w" "${w%.webp}.jpg" && rm "$w"; done'

# set tabby tab name title
alias tn="printf '\033]2;%s\007'"

# pager/editor
export PAGER=less
export LESS='-RC'
export MANPAGER=less
export EDITOR=nvim
export VISUAL=$EDITOR

# diff
alias vimdiff='nvim -d'
alias nvimdiff=vimdiff

alias pstree='pstree -g3'
alias C=clear

CC() { clear; for _ in $(seq "$LINES"); do echo; done; }

msg() { echo "$*" >&2; }

#!/usr/bin/env bash
# Consistent message badges for Nerd Font terminals (no bold, dark theme friendly)

# --- Color helpers ------------------------------------------------------
RESET="\033[0m"
WHITE="\033[97m"

# --- Badge corners ------------------------------------------------------
LEFT_CORNER=""
RIGHT_CORNER=""

# --- Error message (red) -----------------------------------------------
errmsg() {
  local RED="\033[31m"
  local RED_BG="\033[41m"
  echo
  printf "%b\n" \
    "${RED}${LEFT_CORNER}${RED_BG}${WHITE} error ${RESET}${RED}${RIGHT_CORNER}${RESET} $*"
  echo
}

# --- Warning message (orange) ------------------------------------------
warnmsg() {
  # Truecolor orange (foreground + background)
  local ORANGE_FG="\033[38;2;255;140;0m"
  local ORANGE_BG="\033[48;2;255;140;0m"
  echo
  printf "%b\n" \
    "${ORANGE_FG}${LEFT_CORNER}${ORANGE_BG}${WHITE} warning ${RESET}${ORANGE_FG}${RIGHT_CORNER}${RESET} $*"
  echo
}

# --- Info message (blue) -----------------------------------------------
hintmsg() {
  local BLUE="\033[34m"
  local BLUE_BG="\033[44m"
  echo
  printf "%b\n" \
    "${BLUE}${LEFT_CORNER}${BLUE_BG}${WHITE} hint ${RESET}${BLUE}${RIGHT_CORNER}${RESET} $*"
  echo
}

# --- OK message (green) -------------------------------------------------
okmsg() {
  local GREEN="\033[32m"
  local GREEN_BG="\033[42m"
  local WHITE="\033[97m"
  local RESET="\033[0m"

  local LEFT_CORNER=""
  local RIGHT_CORNER=""

  printf "%b\n" \
    "${GREEN}${LEFT_CORNER}${GREEN_BG}${WHITE} OK ${RESET}${GREEN}${RIGHT_CORNER}${RESET} $*"
}

arrowmsg() {
  # Usage:
  #   arrowmsg "Message text"
  #   arrowmsg red "Message text"
  #
  # Supported colors: green (default), red, orange, yellow, blue, cyan, magenta, white, grey

  local COLOR_NAME="green"
  local RESET="\033[0m"
  local POINTER="➜"

  # If first argument matches a color name, treat it as color
  case "$1" in
    red|orange|yellow|green|blue|cyan|magenta|white|grey)
      COLOR_NAME="$1"
      shift
      ;;
  esac

  # Define truecolor mappings
  case "$COLOR_NAME" in
    red)     COLOR="\033[38;2;255;70;70m" ;;
    orange)  COLOR="\033[38;2;255;140;0m" ;;
    yellow)  COLOR="\033[38;2;255;215;0m" ;;
    green)   COLOR="\033[38;2;50;205;50m" ;;
    blue)    COLOR="\033[38;2;80;160;255m" ;;
    cyan)    COLOR="\033[38;2;0;200;200m" ;;
    magenta) COLOR="\033[38;2;255;100;255m" ;;
    white)   COLOR="\033[97m" ;;
    grey)    COLOR="\033[38;2;180;180;180m" ;;
  esac

  printf "%b\n" "${COLOR}${POINTER} $*${RESET}"
}


# ============================================================================
# helpers
# ============================================================================

in_path() { printf '%s\n' "$PATH" | grep -q "(^|:)$1(:|$)"; }

is_worker_path() {
    case "$PWD" in
        "$HOME"|"$WORK"|"$EDU") return 1 ;;
        *) return 0 ;;
    esac
}

show_path() { tr -s : '\n' <<<"$PATH"; }

edit_path() {
    local tmpf; tmpf=$(mktemp)
    show_path >"$tmpf"
    "${EDITOR:-vi}" "$tmpf"
    export PATH=$(tr '\n' : <"$tmpf" | grep -vE '^ *(#|$)')
    rm -f "$tmpf"
}

locate_prog() {
    local prog="$1"
    if alias "$prog" >/dev/null 2>&1; then
        echo "Is an alias" >&2; return 1
    fi
    local fullpath; fullpath=$(command -v "$prog" 2>/dev/null) || {
        echo "Not found" >&2; return 1; }
    local basepath=${fullpath%/*}
    show_path | while read -r p; do
        [ "$p" = "$basepath" ] && echo "==> $p" || echo "    $p"
    done
}

cdp() {
    local choosen="$($HOME/app/lkltools/cdp.sh -n -c3600 call $@)"

    [ -z $choosen ] && return 0

    if [ ! -d "$choosen" ]
    then
        echo "Dir $choosen does not exist!?" >&2
        return 1
    fi

    cd $choosen
}

# ============================================================================
# PATH handling
# ============================================================================

path_prepend() {
    case ":$PATH:" in *":$1:"*) ;; *) PATH="$1:$PATH";; esac
}

for d in ~/bin ~/.local/bin ~/.rd/bin \
    ~/app/bin ~/app/groovy-lsp ~/app/jenkins-cli \
    ~/.npm-global ~/app/lkltools /opt/homebrew/opt/coreutils/bin
do
    [ -d "$d" ] && path_prepend "$d"
done

# homebrew detection
for d in /opt/homebrew "$HOME/.linuxbrew" /home/linuxbrew/.linuxbrew; do
    if [ -x "$d/bin/brew" ]; then
        eval "$("$d/bin/brew" shellenv)"
        export HOMEBREW_NO_ENV_HINTS=y
        export BREW_BIN="$d/bin"
        break
    fi
done

# ============================================================================
# go
# ============================================================================
alias glr='go run .'
alias glb='go vet && staticcheck && go fmt && go build .'
alias glc='go vet && staticcheck && go fmt && go build -ldflags "-w -s" .'
alias glf='go fmt'

# ============================================================================
# rust
# ============================================================================
[ -f "$HOME/.cargo/env" ] && . "$HOME/.cargo/env" && export RUST_BACKTRACE=1

# ============================================================================
# python
# ============================================================================
alias uvr='uv run'
alias uvt='uv test'

alias vea='[ -f .venv/bin/activate ] && . .venv/bin/activate || echo "No venv here!" >&2'
alias ved='[ -n "$VIRTUAL_ENV" ] && deactivate || echo "Not in a venv!" >&2'

# ============================================================================
# ssh
# ============================================================================

# ===========================================================
#  Persistent ssh-agent (single socket, multi-login safe)
# ===========================================================
export SSH_AUTH_SOCK="$HOME/.ssh/agent.sock"
export SSH_AGENT_PID_FILE="$HOME/.ssh/agent.pid"

start_agent() {
  echo "Starting new ssh-agent..."
  rm -f "$SSH_AUTH_SOCK"
  eval "$(ssh-agent -a "$SSH_AUTH_SOCK")" >/dev/null
  echo $SSH_AGENT_PID >"$SSH_AGENT_PID_FILE"
}

# Check if agent PID file exists and is alive
if [[ -f "$SSH_AGENT_PID_FILE" ]]; then
  pid=$(<"$SSH_AGENT_PID_FILE")
  if ! ps -p "$pid" >/dev/null 2>&1; then
    # stale PID, restart agent
    start_agent
  fi
else
  # No PID file yet, start agent
  start_agent
fi



# ============================================================================
# fzf
# ============================================================================
if [ -n "$ZSH_NAME" ]; then
    eval "$(fzf --zsh)"
else
    eval "$(fzf --bash)"
fi

export FZF_DEFAULT_OPTS='--extended --layout=default --color=dark --style=full:rounded --height=50% --tmux 90%'
export FZF_DEFAULT_COMMAND='fd --no-hidden -E __pycache__ -E node_modules'
export FZF_CTRL_T_COMMAND='fd --strip-cwd-prefix'
export FZF_CTRL_T_OPTS="--bind='ctrl-p:execute:bat --style=numbers {}' --bind='ctrl-e:execute:nvim {}' --preview='test -f {} && bat --color=always --theme=gruvbox-dark --style=plain --line-range=:50 {} --paging=never || eza --tree -I __pycache__ -I node_modules -L=8 --color=always {}'"

e() {
  # Define options: short (-a, -b) and long (--alpha, --beta)
  local opts
  opts=$(getopt -o a,b: -l ,beta: -- "$@") || return 1
  eval set -- "$opts"

  local alpha=false
  local beta_value=""

  while true; do
    case "$1" in
      -a|--alpha)
        alpha=true
        shift
        ;;
      -b|--beta)
        beta_value="$2"
        shift 2
        ;;
      --)
        shift
        break
        ;;
      *)
        echo "Invalid option: $1" >&2
        return 1
        ;;
    esac
  done

  echo "alpha=$alpha"
  echo "beta_value=$beta_value"
  echo "remaining args: $*"
}

# ============================================================================
# mise
# ============================================================================
case $SHELL in
    */bash) eval "$(mise activate bash)" ;;
    */zsh)  eval "$(mise activate zsh)" ;;
    *) echo "Don't know how to init mise for shell $SHELL" >&2 ;;
esac

mst() {
    if ! is_worker_path; then
        echo "Do not run here!"; return 1
    fi
    local choice; choice=$(mise list | awk '{print $1 " " $2}' | fzf) || return 1
    choice=${choice/ /@}; choice=${choice/\/}
    [ -n "$choice" ] && mise use "$choice"
}

# ============================================================================
# aws
# ============================================================================
export AWS_CMD=aws
unset AWS_PAGER

alias aws_credentials_export='perl -00ne "/\{.+\"Credentials\":\s.+\"AccessKeyId\":\s+\"([^\"]+)\".+\"SecretAccessKey\":\s+\"([^\"]+)\".+\"SessionToken\":\s+\"([^\"]+)\"/s; print qq{export AWS_ACCESS_KEY_ID=\"\$1\";export AWS_SECRET_ACCESS_KEY=\"\$2\";export AWS_SESSION_TOKEN=\"\$3\"\n}"'

aws_gt() {
    [ $# -eq 4 ] || [ $# -eq 2 ] || { echo "usage: aws_gt profile region [mfa token_code]"; return 1; }
    local profile=$1 region=$2 mfa=$3 token=$4
    local out rc export_cmd
    local cmd="$AWS_CMD sts get-session-token --profile $profile"
    [ -n "$mfa" ] && out=$($cmd --serial-number "$mfa" --token-code "$token") || out=$($cmd)
    rc=$?
    [ $rc -eq 0 ] || { echo "ups: rc=$rc"; echo "$out"; return 1; }
    export_cmd=$(aws_credentials_export <<<"$out") || return 1
    eval "$export_cmd; export AWS_PROFILE=$profile; export AWS_DEFAULT_REGION=$region"
    echo "--> now connected to AWS account \"$profile\" (region \"$region\")"
}

alias bat="$HOME/.cargo/bin/bat --color=auto --theme=vague"
alias pbat='bat -p'
alias nbat='bat -n'

# ============================================================================
# git
# ============================================================================
alias gbl='git blame'
alias gbr='git rev-parse --abbrev-ref HEAD'
alias gcl='git status --porcelain=v1 | grep -q . || true'
alias glr='git log --reverse'
alias gor="git remote -v | awk '/^origin/ && NR==1 {print \$2}'"
alias gpl='git pull'
alias gst='git status'
alias gcm='git commit -m'
alias gta='git add -A . && git commit -m'

gpa() {
    local message
    message="$*"

    git add -A .
    git commit -m "$message"
    git push
}

# git push (set upstream origin if required)
gpu() {
    if [ -n "$(gor)" ]
    then
        git push
    else
        git push --set-upstream origin "$(gbr)"
    fi
}

gmi() {
    if [ ! -d $PWD/.git ]
    then
       msg "No git dir"
       return 1
    fi

    if [ -f $PWD/.gitignore ]
    then
       msg ".gitignore aleady exist"
       return 1
    fi

    /bin/cat >.gitignore <<EOF
.DS_Store
__pycache__
*.pyc
npm_modules
*.o
.env
?  # throw-away executors like x or even y...
EOF
}

chbranch() {
    local br; br=$(git branch -a | grep -v '^\*' | sed -e 's/^  *//' -e 's%remotes/origin/%%' | fzf) || return 1
    git checkout "$br" && echo "Switched to $br"
}

export GIT_PAGER=cat

# ============================================================================
# tmux
# ============================================================================
alias clean_tmux_sessions='tmux ls -F "#S #{session_attached}" | awk "$2==0{print $1}" | xargs -r -n1 tmux kill-session -t'

# ============================================================================
# eye candy + extras
# ============================================================================
if [ -n "$SSH_CONNECTION" ] && [ -z "$MADE_NEOFETCH_CALL" ] && command -v neofetch >/dev/null; then
    neofetch
    export MADE_NEOFETCH_CALL=y
fi

[ -f "$HOME/.config/broot/launcher/bash/br" ] && . "$HOME/.config/broot/launcher/bash/br"

# ============================================================================
# private local settings
# ============================================================================

[ -s "$HOME/.env" ] && source "$HOME/.env"

[ -s "$HOME/.common_interactive_local_sh" ] && source "$HOME/.common_interactive_local_sh"

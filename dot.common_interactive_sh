# ============================================================================
# generic stuff
# ============================================================================

alias vi=nvi

# tmpdir
export TMPDIR="$HOME/tmp"
[ -d "$TMPDIR" ] || mkdir -p -- "$TMPDIR"

# sane defaults
ulimit -c 0 -n 4096
umask 002

# detect OS
case "$(uname -s)" in
    Darwin) THIS_OS=mac ;;
    Linux)  THIS_OS=linux ;;
    *)      THIS_OS=unknown ;;
esac
export THIS_OS

[ "$THIS_OS" = linux ] && alias open=exo-open

# paths

export EZA_CONFIG_DIR="$HOME/.config/eza"

export XDG_CONFIG_HOME="$HOME/.config"
export XDG_CACHE_HOME="$HOME/.cache"
export XDG_DATA_HOME="$HOME/.local/share"

export WORK="$HOME/work"
export EDU="$HOME/edu"
export DF="$HOME/.dotfiles"
export NCONF="$DF/config/nvim"
export NCONF_LUA="$NCONF/lua/config"

alias s='source'

alias eci='nvim $DF/dot.common_interactive_sh'

# --- jump aliases
alias cdw='cd "$WORK" && lltr'
alias cde='cd "$EDU" && lltr'
alias cdnc='cd "$NCONF" && lltr'
alias cdncl='cd "$NCONF_LUA" && lltr'
alias cddf='cd "$DF" && lltr'

export ca=' --color=always '

# --- ls aliases (eza)
export EZA_TREE_LEVEL=5
alias l="$(which eza) --git --icons=auto --group-directories-first -X --level="${EZA_TREE_LEVEL:-8}" --color=always"
alias ll='l -l'
alias la='l -a'
alias lla='l -la'
alias llt='ll --sort age'
alias lltr='llt --reverse'

# --- grep aliases
alias grep='grep --color=auto'
alias egrep='grep -E'
alias fgrep='grep -F'

# misc tools
alias dua="$BREW_BIN/dua -t4 interactive"
alias nrg='rg --color=never'
alias webp2jpg='for w in *.webp; do convert "$w" "${w%.webp}.jpg" && rm "$w"; done'

# set tabby tab name title
alias tn="printf '\033]2;%s\007'"

# pager/editor
export PAGER=less
export LESS='-RC'
export MANPAGER=less
export EDITOR=nvim
export VISUAL=$EDITOR

# diff
alias vimdiff='nvim -d'
alias nvimdiff=vimdiff

alias pstree='pstree -g3'
alias C=clear

CC() { clear; for _ in $(seq "$LINES"); do echo; done; }

msg() { echo "$*" >&2; }

# ============================================================================
# helpers
# ============================================================================

in_path() { printf '%s\n' "$PATH" | grep -q "(^|:)$1(:|$)"; }

is_worker_path() {
    case "$PWD" in
        "$HOME"|"$WORK"|"$EDU") return 1 ;;
        *) return 0 ;;
    esac
}

show_path() { tr -s : '\n' <<<"$PATH"; }

edit_path() {
    local tmpf; tmpf=$(mktemp)
    show_path >"$tmpf"
    "${EDITOR:-vi}" "$tmpf"
    export PATH=$(tr '\n' : <"$tmpf" | grep -vE '^ *(#|$)')
    rm -f "$tmpf"
}

locate_prog() {
    local prog="$1"
    if alias "$prog" >/dev/null 2>&1; then
        echo "Is an alias" >&2; return 1
    fi
    local fullpath; fullpath=$(command -v "$prog" 2>/dev/null) || {
        echo "Not found" >&2; return 1; }
    local basepath=${fullpath%/*}
    show_path | while read -r p; do
        [ "$p" = "$basepath" ] && echo "==> $p" || echo "    $p"
    done
}

cdpo() {
    [ $# -eq 1 ] || { echo '???' >&2; return 1; }
    local prog="$1" fullpath
    if alias "$prog" >/dev/null 2>&1; then
        echo "Is an alias" >&2; return 1
    fi
    fullpath=$(command -v "$prog" 2>/dev/null) || {
        echo "Not found" >&2; return 1; }
    cd "${fullpath%/*}" || return 1
}

# ============================================================================
# PATH handling
# ============================================================================

path_prepend() {
    case ":$PATH:" in *":$1:"*) ;; *) PATH="$1:$PATH";; esac
}

for d in ~/bin ~/.local/bin ~/.rd/bin \
    ~/app/bin ~/app/groovy-lsp ~/app/jenkins-cli ~/app/{go,VSCode-linux-x64}/bin \
    ~/.npm-global ~/app/lkltools /opt/homebrew/opt/coreutils/bin
do
    [ -d "$d" ] && path_prepend "$d"
done

# homebrew detection
for d in /opt/homebrew "$HOME/.linuxbrew" /home/linuxbrew/.linuxbrew; do
    if [ -x "$d/bin/brew" ]; then
        eval "$("$d/bin/brew" shellenv)"
        export HOMEBREW_NO_ENV_HINTS=y
        export BREW_BIN="$d/bin"
        break
    fi
done

# ============================================================================
# go
# ============================================================================
alias gr='go run .'
alias gb='go vet && staticcheck && go fmt && go build .'
alias gbs='go vet && staticcheck && go fmt && go build -ldflags "-w -s" .'
alias gf='go fmt'

# ============================================================================
# rust
# ============================================================================
[ -f "$HOME/.cargo/env" ] && . "$HOME/.cargo/env" && export RUST_BACKTRACE=1

# ============================================================================
# python
# ============================================================================
alias ur='uv run'
alias vea='[ -f .venv/bin/activate ] && . .venv/bin/activate || echo "No venv here!" >&2'
alias ved='[ -n "$VIRTUAL_ENV" ] && deactivate || echo "Not in a venv!" >&2'

# ============================================================================
# ssh
# ============================================================================

# ===========================================================
#  Persistent ssh-agent (single socket, multi-login safe)
# ===========================================================
export SSH_AUTH_SOCK="$HOME/.ssh/agent.sock"
export SSH_AGENT_PID_FILE="$HOME/.ssh/agent.pid"

start_agent() {
  echo "Starting new ssh-agent..."
  rm -f "$SSH_AUTH_SOCK"
  eval "$(ssh-agent -a "$SSH_AUTH_SOCK")" >/dev/null
  echo $SSH_AGENT_PID >"$SSH_AGENT_PID_FILE"
}

# Check if agent PID file exists and is alive
if [[ -f "$SSH_AGENT_PID_FILE" ]]; then
  pid=$(<"$SSH_AGENT_PID_FILE")
  if ! ps -p "$pid" >/dev/null 2>&1; then
    # stale PID, restart agent
    start_agent
  fi
else
  # No PID file yet, start agent
  start_agent
fi



# ============================================================================
# fzf
# ============================================================================
if [ -n "$ZSH_NAME" ]; then
    eval "$(fzf --zsh)"
else
    eval "$(fzf --bash)"
fi

export FZF_DEFAULT_OPTS='--extended --layout=default --color=dark --style=full:rounded --height=50% --tmux 90%'
export FZF_DEFAULT_COMMAND='fd --no-hidden -E __pycache__ -E node_modules'
export FZF_CTRL_T_COMMAND='fd --strip-cwd-prefix'
export FZF_CTRL_T_OPTS="--bind='ctrl-p:execute:bat --style=numbers {}' --bind='ctrl-e:execute:nvim {}' --preview='test -f {} && bat --color=always --theme=gruvbox-dark --style=plain --line-range=:50 {} --paging=never || eza --tree -I __pycache__ -I node_modules -L=8 --color=always {}'"

fze() { local f; f=$(fzf) && [ -n "$f" ] && "$EDITOR" "$f"; }
fcd() { local d; d=$(fd -t d | fzf) && [ -n "$d" ] && cd "$d"; }

# ============================================================================
# mise
# ============================================================================
case $SHELL in
    */bash) eval "$(mise activate bash)" ;;
    */zsh)  eval "$(mise activate zsh)" ;;
    *) echo "Don't know how to init mise for shell $SHELL" >&2 ;;
esac

mst() {
    if ! is_worker_path; then
        echo "Do not run here!"; return 1
    fi
    local choice; choice=$(mise list | awk '{print $1 " " $2}' | fzf) || return 1
    choice=${choice/ /@}; choice=${choice/\/}
    [ -n "$choice" ] && mise use "$choice"
}

# ============================================================================
# aws
# ============================================================================
export AWS_CMD=aws
unset AWS_PAGER

alias aws_credentials_export='perl -00ne "/\{.+\"Credentials\":\s.+\"AccessKeyId\":\s+\"([^\"]+)\".+\"SecretAccessKey\":\s+\"([^\"]+)\".+\"SessionToken\":\s+\"([^\"]+)\"/s; print qq{export AWS_ACCESS_KEY_ID=\"\$1\";export AWS_SECRET_ACCESS_KEY=\"\$2\";export AWS_SESSION_TOKEN=\"\$3\"\n}"'

aws_gt() {
    [ $# -eq 4 ] || [ $# -eq 2 ] || { echo "usage: aws_gt profile region [mfa token_code]"; return 1; }
    local profile=$1 region=$2 mfa=$3 token=$4
    local out rc export_cmd
    local cmd="$AWS_CMD sts get-session-token --profile $profile"
    [ -n "$mfa" ] && out=$($cmd --serial-number "$mfa" --token-code "$token") || out=$($cmd)
    rc=$?
    [ $rc -eq 0 ] || { echo "ups: rc=$rc"; echo "$out"; return 1; }
    export_cmd=$(aws_credentials_export <<<"$out") || return 1
    eval "$export_cmd; export AWS_PROFILE=$profile; export AWS_DEFAULT_REGION=$region"
    echo "--> now connected to AWS account \"$profile\" (region \"$region\")"
}

alias bat="$BREW_BIN/bat --color=auto --theme=Nord"
alias pbat='bat -p'
alias nbat='bat -n'

# ============================================================================
# git
# ============================================================================
alias gl='git log --reverse'
alias gbr='git rev-parse --abbrev-ref HEAD'
alias gpbr='git push --set-upstream origin $(gbr)'
alias gor="git remote -v | awk '/^origin/ && NR==1 {print \$2}'"

mk_gitignore() {
    cat >.gitignore <<EOF
.DS_Store
__pycache__
*.pyc
npm_modules
*.o
.env
EOF
}

ginit() {
    local dir=${1:-}
    [ -n "$dir" ] && { [ -d "$dir" ] && { msg "dir exists"; return 1; } || mkdir -p "$dir" && cd "$dir"; }
    [ ! -f README.md ] && echo -e "# Description\n\nBla..." >README.md
    mk_gitignore
    git init && git add -A . && git commit -m "initial version"
}

mkbranch() {
    [ $# -ge 1 ] || { msg "usage: mkbranch branch [origin]"; return 1; }
    git checkout -b "$1" && git push "${2:-origin}" "$1"
}
chbranch() {
    local br; br=$(git branch -a | grep -v '^\*' | sed -e 's/^  *//' -e 's%remotes/origin/%%' | fzf) || return 1
    git checkout "$br" && echo "Switched to $br"
}
alias mbr=mkbranch
alias cbr=chbranch
export GIT_PAGER=cat

# ============================================================================
# tmux
# ============================================================================
alias clean_tmux_sessions='tmux ls -F "#S #{session_attached}" | awk "$2==0{print $1}" | xargs -r -n1 tmux kill-session -t'

# ============================================================================
# eye candy + extras
# ============================================================================
if [ -n "$SSH_CONNECTION" ] && [ -z "$MADE_NEOFETCH_CALL" ] && command -v neofetch >/dev/null; then
    neofetch
    export MADE_NEOFETCH_CALL=y
fi

[ -f "$HOME/.config/broot/launcher/bash/br" ] && . "$HOME/.config/broot/launcher/bash/br"

# ============================================================================
# private local settings
# ============================================================================
[ -s "$HOME/.common_interactive_local_sh" ] && . "$HOME/.common_interactive_local_sh"
